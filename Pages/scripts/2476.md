---
pid:            2476
author:         Joel Bennett
title:          Experimental.IO 1.0
date:           2011-01-25 14:54:02
format:         posh
parent:         0

---

# Experimental.IO 1.0

### [download](//scripts/2476.ps1)

Here's a first simple hit on how to use the Experimental.IO LongPath library from the "Microsoft Base Class Library":http://bcl.codeplex.com codeplex project.  Will list files and/or folders (recursively) ... 

It does NOT create a FileInfo object (because those don't support long paths), so it's *much* faster than Get-ChildItem, but it outputs only strings. Maybe someone else can make a few helper functions for the other methods in this assembly (Get-LongPathContent, Set-LongPathContent, Remove-LongPathItem, ...)

```posh
## Requires the Experimental.IO "LongPath" library from the BCL team: http://bcl.codeplex.com/
## Compile it against .Net 3.5 (for PowerShell's sake) and place it the module folder with this psm1
if(!("Microsoft.Experimental.IO.LongPathDirectory" -as [type])) {
   Add-Type -Path $PSScriptRoot\Microsoft.Experimental.IO.dll
}

function Get-LongPath {
[CmdletBinding(DefaultParameterSetName="AllItems")]
param(
   [Parameter(Position=0,ValueFromPipelineByPropertyName=$true,ValueFromPipeline=$true)]
   [string]$Path = $pwd
, 
   [Parameter(ParameterSetName="DirectoriesOnly")]
   [Alias("od","do")]
   [switch]$DirectoriesOnly
, 
   [Parameter(ParameterSetName="FilesOnly")]
   [Alias("of","fo")]
   [switch]$FilesOnly
,
   [switch]$Recurse
,
   [switch]$Indent
)
begin {
   if($Recurse -and $Indent -and (Test-Path variable:script:pad)) {
      $script:pad += "  "
   } else {
      $script:pad = ""
   }
   $null = $PSBoundParameters.Remove("Path")
   if($PSCmdlet.ParameterSetName -eq "FilesOnly") {
      Write-Verbose $Path
   }
}
process {
   switch($PSCmdlet.ParameterSetName) {
      "FilesOnly" {
         if($Recurse) {
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateFileSystemEntries( $Path ) | %{ 
               if( [Microsoft.Experimental.IO.LongPathDirectory]::Exists( $_ ) ) {
                  Get-LongPath $_ @PSBoundParameters
               } else {
                  $script:pad + $_
               }
            }
         } else {
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateFiles( $Path )
         }
      }
      "DirectoriesOnly" {
         if($Recurse) {
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateDirectories( $Path ) | %{ 
               $script:pad + $_ + "\"
               if($recurse) {
                  Get-LongPath $_ @PSBoundParameters
               }
            }
         } else {
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateDirectories( $Path )
         }
      }
      "AllItems" {
         if($recurse) {
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateFileSystemEntries( $Path ) | %{ 
               if( [Microsoft.Experimental.IO.LongPathDirectory]::Exists( $_ ) ) {
                  $script:pad + $_ + "\"
                  Get-LongPath $_ @PSBoundParameters
               } else {
                  $script:pad + $_
               }
            }
         } else { 
            [Microsoft.Experimental.IO.LongPathDirectory]::EnumerateFileSystemEntries( $Path )
         }
      }
   }
}
end {
   if($Indent) {
      if($script:pad.Length -gt 0) {
         $script:pad = $script:pad.SubString(0, $script:pad.Length - 2)
      } else {
         remove-item variable:script:pad -EA 0
      }
   }
}
}

```
